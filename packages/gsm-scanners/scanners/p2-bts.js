var tSharkCMD, airprobeCMD, tSharkCaptures, arfcn, scanner, callback // things that must be file global

GSMScanners.P2BTS = {
  // options: arfcnId, fromFile = false, duration, pythonLocation, airprobeLocation, [tsharkCaptures], scanner (optional)
  // options: arfcnId, fromFile = true, fileLocation, tsharkLocation, [tsharkCaptures], scanner (optional)
  run: function(options, callbck) {
    Status.set("Entering BTS...")
    callback = callbck
    tSharkCaptures = options.tSharkCaptures
    scanner = options.scanner
    arfcn = ARFCNs.ARFCNs.findOne(options.arfcnId)
    startTShark(options, callback)

    if(options.fromFile) {
      Status.set("Read from file")
    } else {
      Status.set("Read from airprobe")
      deepScanCurrentARFCN(options)
      Meteor.setTimeout(function() {
        Status.set("Stopping scan on frequency: " + arfcn.centerFreq);
        airprobeCMD.kill();
        tSharkCMD.kill();
      }, options.duration * 1000); // 100 ms to let previous scan die
    }
  }
}

var startTShark = function(options, callback) {
  var spawn = Npm.require('child_process').spawn
  var tSharkArgs = buildTSharkArgs(options)

  tSharkCMD = spawn(options.tSharkLocation, tSharkArgs);

  tSharkCMD.stdout.on('data', Meteor.bindEnvironment( // required because defining callback on server
    parseTSharkCSV,
    function () { Status.set("Failed to bind environment!"); }
  ));

  tSharkCMD.stderr.on('data', Meteor.bindEnvironment(
    function (data) {
      //Status.set('tsharkCMDstderr: ' + data);
  }, function () { Status.set("Failed to bind environment!"); }));

  tSharkCMD.on('exit', Meteor.bindEnvironment(
    function (code) {
        Status.set('tsharkCMDchild process exited with code ' + code);
        // give time to shutdown properly
        Meteor.setTimeout(function() {
          callback(undefined, true)
        }, 2 * 1000)
  }, function () { Status.set("Failed to bind environment!"); }));
}

// Parse CSV data generated by tshark into individual readings
var parseTSharkCSV = function(data) {
  //  Status.set("tShark STDOUT: " + data.toString());

  var config = {
    delimiter: "",	// auto-detect
    newline: "",	// auto-detect
    dynamicTyping: true,
  }

  var results = Papa.parse(data.toString(), config);
  var readings = results.data;
  var errors = results.errors;
  var metadata = results.metadata;

  if(readings) {
    //  Status.set("Captured new batch of data");
    readings.forEach(function(reading) {
      // Status.set("Parsing individual packet: " + reading);

      if(reading.length > 0) {
          // Status.set("Packet ACCEPTED");
          var pat = /^0x.*/
          var hexRegex = new RegExp(pat)
          // Status.set(reading)
          reading = _.map(reading, function(v) {
            // convert hex and strings to int
            if(hexRegex.test(v)) {
              return parseInt(v)
            }
            return parseFloat(v)
          })

          var defaultVal = -9999
          var cid = sanitizedReadingAtt(reading, 'gsm_a.bssmap.cell_ci', defaultVal)
          var imsi = sanitizedReadingAtt(reading, 'gsm_a.tmsi', defaultVal)
          var tmsi = sanitizedReadingAtt(reading, 'gsm_a.imsi', defaultVal)
        /**  var mobileIdentity = sanitizedReadingAtt(reading, 'gsm_a.ie.mobileid.type', defaultVal)
          var statusPagingChannel = sanitizedReadingAtt(reading, 'gsm_a.rr.nln_pch', defaultVal)
        **/
          /**delete the "4" and "1" in the imsi-array **/
        if (imsi < 10) { imsi = -9999   }
        if (tmsi < 10) { tmsi = -9999   }

          if((cid > 0) || (imsi > 0) || (tmsi > 0)
           /**|| (mobileIdentity > 0) || (statusPagingChannel > 0) **/
         )
             {

            var now = new Date()
            var readingId = GSMReadings.GSMReadings.insert({
              scanner:              scanner || "P2BTS",
              arfcnId:              arfcn._id,
              frequency:            arfcn.centerFreq,
              cid:                  cid,
              mcc:                  sanitizedReadingAtt(reading, 'e212.mcc', defaultVal),
              mnc:                  sanitizedReadingAtt(reading, 'e212.mnc', defaultVal),
              lac:                  sanitizedReadingAtt(reading, 'gsm_a.lac', defaultVal),
              signalStrength:       sanitizedReadingAtt(reading, 'gsmtap.signal_dbm', defaultVal),
              signalNoise:          sanitizedReadingAtt(reading, 'gsmtap.snr_db', defaultVal),
              locUpTimer:           sanitizedReadingAtt(reading, 'gsm_a.rr.t3212', defaultVal),
            /**  mobileIdentity:       mobileIdentity,
              statusPagingChannel:  statusPagingChannel,
              pagingChannel:        sanitizedReadingAtt(reading, 'gsm_a.rr.nln_status_pch', defaultVal),
            **/  imsi:                 imsi,
              tmsi:                 tmsi,
              timestamp:            now
            });
          }
        }
    })
  }

  if(errors) {
    // Status.set("tsharkCMD errors: " + errors);
  }

  if(metadata) {
    // Status.set("tsharkCMD meta: " + metadata.delimeter);
  }
}

// looks up the reading for a given attribute name or return a default
var sanitizedReadingAtt = function(reading, attName, def) {
  var r = reading[tSharkArgIndex(attName)]
  return r || def
}

// Return attribute position in response based on order in original request
var tSharkArgIndex = function(arg) {
  return tSharkCaptures.indexOf(arg)
}

// Starts Airprobe to scan for GSM data
var deepScanCurrentARFCN = function(options) {
  Status.set("Starting Airprobe on " + arfcn.centerFreq + "MHz");
  var spawn = Npm.require('child_process').spawn
  airprobeCMD = spawn(options.pythonLocation, [
    options.airprobeLocation,
    '-f', arfcn.centerFreq.toString() + 'M'
  ]);

  airprobeCMD.stdout.on('data', function (data) {
    // Status.set("stdout: " + data);
  });

  airprobeCMD.stderr.on('data', function (data) {
    // Status.set('stderr: ' + data);
  });

  airprobeCMD.on('exit', Meteor.bindEnvironment(
    function (code, signal) {
      Status.set('deepScanCurrentARFCN child process exited with code ' + code + " and signal " + signal);
      if(signal == "SIGTERM") { // success
        Status.set("Finished scanning");
      }
    }, function () { Status.set("deepScanCurrentARFCN Failed to bind environment!"); }
  ));
};

var buildTSharkArgs = function(options) {
    var tSharkArgs = [ // capture using wireshark terminal tool
      '-T', 'fields', '-E', 'separator=,', // output to CSV
      '-l',
    ]

    // Args depending on if reading from file or from loopback
    if(options.fromFile) {
      // Status.set("buildTSharkArgs from file")
      tSharkArgs = tSharkArgs.concat([
        '-r', options.fileLocation // Read from fileLocation
      ])

    } else {
      // Status.set("buildTSharkArgs from Airprobe")
      tSharkArgs = tSharkArgs.concat([
        '-i', 'lo', // on the loopback interface
        '-f', 'udp dst port 4729', // filter everything but UDP on port 4729 (gsmtap)
      ])
    }

    // Add each capture to tSharkArgs as `-e arg`
    var captureArgs = []
    _.each(tSharkCaptures, function(arg) {
      captureArgs.push('-e')
      captureArgs.push(arg)
    })

    tSharkArgs = tSharkArgs.concat(captureArgs)

    return tSharkArgs
}
